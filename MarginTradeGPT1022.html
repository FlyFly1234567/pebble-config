<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Pebble · 对冲开仓画布（单文件）</title>
<style>
  :root{
    --bg:#0b0e14;--card:#0f141b;--muted:#8a94a7;--fg:#e6edf3;--border:#1e2633;
    --accent:#6366f1;--good:#10b981;--bad:#ef4444;--warn:#f59e0b;
  }
  *{box-sizing:border-box} html,body{margin:0;padding:0;background:var(--bg);color:var(--fg);
    font:14px/1.6 ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Helvetica Neue,Arial,PingFang SC}
  .wrap{max-width:1200px;margin:24px auto;padding:0 16px}
  h1{font-size:24px;margin:0 0 16px;font-weight:700}
  .grid{display:grid;gap:16px}
  .g-3{grid-template-columns:320px 1fr}
  @media (max-width: 980px){.g-3{grid-template-columns:1fr}}
  .card{background:var(--card);border:1px solid var(--border);border-radius:16px;padding:16px}
  .title{font-weight:700;margin-bottom:8px}
  .muted{color:var(--muted)}
  .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  input,button{font:inherit}
  input[type=number], input[type=text]{background:#0b0f16;border:1px solid var(--border);color:var(--fg);
     border-radius:10px;padding:8px 10px;min-width:0;outline:none}
  .btn{background:#151b26;border:1px solid var(--border);color:var(--fg);
     border-radius:10px;padding:8px 12px;cursor:pointer}
  .btn.secondary{background:#101521}
  .btn.ghost{background:transparent}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  .kpi{display:grid;grid-template-columns:repeat(4,1fr);gap:10px}
  .k{background:#0c121b;border:1px solid var(--border);border-radius:12px;padding:12px}
  .k .lab{font-size:12px;color:var(--muted)}
  .k .val{font-size:20px;font-weight:700;margin-top:4px}
  table{width:100%;border-collapse:collapse}
  th,td{padding:10px;border-bottom:1px solid var(--border);text-align:right}
  th:first-child,td:first-child{text-align:left}
  .tag{font-size:11px;padding:3px 8px;border-radius:999px;background:#161c27;border:1px solid var(--border);color:#c7d2fe}
  .badge{font-size:11px;padding:2px 7px;border-radius:999px;color:#fff}
  .b-long{background:linear-gradient(90deg,#10b981,#22c55e)}
  .b-short{background:linear-gradient(90deg,#ef4444,#f43f5e)}
  .dial{width:180px;height:180px;border-radius:50%;background:conic-gradient(#10b981 0deg 120deg,#f59e0b 120deg 240deg,#ef4444 240deg 360deg);position:relative;margin:auto}
  .dial::after{content:'';position:absolute;inset:14px;background:var(--card);border-radius:50%;z-index:1}
  .needle{position:absolute;left:50%;top:50%;width:3px;height:84px;background:#e5e7eb;transform-origin:bottom center;transform:translate(-50%,-100%) rotate(0deg);z-index:2}
  .dot{position:absolute;left:50%;top:50%;width:6px;height:6px;background:#e5e7eb;border-radius:50%;transform:translate(-50%,-50%);z-index:3}
  .two{display:grid;grid-template-columns:1fr 1fr;gap:14px}
  @media (max-width: 980px){.two{grid-template-columns:1fr}}
  .pill{font-size:12px;border:1px solid var(--border);padding:3px 8px;border-radius:999px;background:#111827}
  .foot{font-size:12px;color:var(--muted);margin-top:10px}
  .err{color:#fca5a5}
</style>
</head>
<body>
  <div class="wrap">
    <h1> Pebble · 对冲开仓画布（单文件）</h1>

    <div class="grid g-3">
      <!-- 左侧：输入与动作 -->
      <div class="card">
        <div class="title">步骤 1 · 存入 USDC</div>
        <div class="row">
          <label>USDC 金额</label>
          <input id="deposit" type="number" min="0" value="10000" style="width:120px">
          <button class="btn secondary" onclick="setDeposit(25000)">+25k</button>
          <button class="btn secondary" onclick="setDeposit(50000)">+50k</button>
        </div>

        <div class="title" style="margin-top:14px">步骤 2 · 行情拉取</div>
        <div class="row">
          <button id="recalc" class="btn" onclick="autoSuggest()">基于实盘重算</button>
          <button id="refresh" class="btn ghost" onclick="refreshAll()">刷新行情</button>
          <span id="updated" class="muted"></span>
        </div>
<div class="foot">行情源：CoinGecko（BTC/ETH/SUI/WAL）· Binance（WAL/USDT）。</div>
        <div id="err" class="err"></div>
      </div>

      <!-- 右侧：轮盘 + KPIs -->
      <div class="card">
        <div class="row" style="justify-content:space-between;margin-bottom:8px">
          <div class="title">自动判定</div>
          <span id="grossPill" class="pill">总杠杆：≈ 2.7×</span>
        </div>
        <div class="two">
          <div class="dial">
            <div id="needle" class="needle"></div>
            <div class="dot"></div>
          </div>
          <div>
            <div class="kpi">
              <div class="k"><div class="lab">建议方向</div><div id="biasText" class="val">—</div></div>
              <div class="k"><div class="lab">净敞口目标</div><div id="netTarget" class="val">—</div></div>
              <div class="k"><div class="lab">多头名义</div><div id="kLong" class="val">—</div></div>
              <div class="k"><div class="lab">空头名义</div><div id="kShort" class="val">—</div></div>
            </div>
            <div class="foot">方向由轮盘分析自动决定；名义会按权重/波动归一化。</div>
          </div>
        </div>
      </div>
    </div>

    <!-- 篮子与明细 -->
    <div class="two" style="margin-top:16px">
      <div class="card" id="altCard"></div>
      <div class="card" id="majCard"></div>
    <div class="card" style="margin-top:16px">
  <div class="title">策略说明</div>
  <div class="muted" style="margin-top:10px;line-height:1.75"><p>系统用 7D/30D 动量混合比较 山寨篮子（SUI/WAL/DEEP） 与 主流篮子（BTC/ETH） 的强弱： 先计算两篮子的动量 momAlt 与 momMaj，再得到 spread = momAlt - momMaj。当 spread &lt; 0 时，山寨相对走弱、风险偏好下降， 资金更偏向流向 BTC/ETH；在这种环境下做空山寨（同时相对做多主流或降低净多）更能对冲 β 风险与回撤。当山寨显著跑输主流（spread &lt; 0）时，系统偏空山寨、偏多主流； 当山寨跑赢（spread &gt; 0）时，方向相反，并随动量与波动自动微调。</p></div>
</div>

    </div>

    <div class="card" style="margin-top:16px">
      <div class="title">建议开仓明细（自动生成）</div>
      <div class="muted">投入USDC数量 = 名义敞口 ÷ 杠杆 → 按比例归一化到你的 USDC（取整，总和=投入）。</div>
      <div style="overflow:auto;margin-top:6px">
        <table id="tbl">
          <thead>
            <tr>
              <th>资产</th><th>方向</th><th>价格</th><th>权重</th><th>杠杆</th>
              <th>名义敞口</th><th>投入USDC数量</th><th>止损</th><th>止盈</th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>
      <div class="foot">* 止损/止盈基于近 30 日波动（或回退 σ）估算；仅作演示。</div>

      <div class="row" style="margin-top:10px">
        <button class="btn" onclick="exportPlan()">导出方案</button>
      </div>
    </div>
  </div>

<script>
// ---------- 小工具 ----------
const $ = s => document.querySelector(s);
const fmt = (n,d=2)=> (isFinite(n)? Number(n).toLocaleString(undefined,{maximumFractionDigits:d}):'—');
const usd = n => (isFinite(n)? '$'+fmt(n, n>999?0:2):'—');
const clamp = (v,lo,hi)=>Math.max(lo,Math.min(hi,v));

// ---------- 配置 ----------
const ALT = [{symbol:'SUI',name:'SUI',id:'sui'},{symbol:'WAL',name:'WAL',id:'walrus-2'},{symbol:'DEEP',name:'DEEP'}];
const MAJ = [{symbol:'BTC',name:'BTC',id:'bitcoin'},{symbol:'ETH',name:'ETH',id:'ethereum'}];
const MIN_LEV=1.1, MAX_LEV=3.0, MIN_GROSS=2.2, MAX_GROSS=3.2;

// ---------- 状态 ----------
let deposit = 10000;
let prices = {SUI:2.6,WAL:0.22,DEEP:0.08,BTC:108000,ETH:3883};
let series = {}; // symbol -> [{ts,price}]
let weightsAlt = {SUI:60,WAL:25,DEEP:15};
let weightsMaj = {BTC:55,ETH:45};
let lev = {SUI:1.26,WAL:1.40,DEEP:1.30,BTC:3.00,ETH:1.86};
let sides = {SUI:'short',WAL:'short',DEEP:'short',BTC:'long',ETH:'long'};
let netBias = -0.2;
let grossLev = 2.7;

// ---------- 行情拉取 ----------
async function fetchGecko(){
  const ids = [...ALT, ...MAJ].filter(x=>x.id).map(x=>x.id).join(',');
  const res = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${ids}&vs_currencies=usd`);
  const data = await res.json();
  const map = {}; [...ALT,...MAJ].forEach(x=> x.id && (map[x.id]=x.symbol));
  Object.entries(data||{}).forEach(([id,v])=>{ const sym=map[id]; if(sym) prices[sym]=v.usd; });
  // 历史（30d）
  for(const x of [...ALT,...MAJ]){
    if(!x.id) continue;
    const h = await fetch(`https://api.coingecko.com/api/v3/coins/${x.id}/market_chart?vs_currency=usd&days=30&interval=daily`).then(r=>r.json());
    series[x.symbol] = (h.prices||[]).map(p=>({ts:p[0], price:p[1]}));
  }
}

async function fetchBinanceWAL(){
  const hosts = ["https://api.binance.com","https://api1.binance.com","https://api2.binance.com","https://api3.binance.com"];
  let got=false;
  for(const host of hosts){
    try{
      const j = await fetch(`${host}/api/v3/ticker/price?symbol=WALUSDT&_=${Date.now()}`,{cache:'no-store'}).then(r=>r.json());
      const p = parseFloat(j.price||j.lastPrice||'');
      if(isFinite(p)){ prices.WAL=p; got=true; break; }
    }catch{}
  }
  if(!got){
    for(const host of hosts){
      try{
        const j = await fetch(`${host}/api/v3/ticker/bookTicker?symbol=WALUSDT&_=${Date.now()}`,{cache:'no-store'}).then(r=>r.json());
        const ask = parseFloat(j.askPrice||''); const bid=parseFloat(j.bidPrice||'');
        if(isFinite(ask)&&isFinite(bid)){ prices.WAL=(ask+bid)/2; got=true; break; }
      }catch{}
    }
  }
}

// ---------- 统计/水平 ----------
function computeStats(arr){
  if(!arr||arr.length<3) return {vol:0.6,r7:0,r30:0};
  const p0=arr[0].price, pe=arr[arr.length-1].price;
  const r30=pe/p0-1;
  const last7=arr.slice(-7); const r7= last7.length? last7[last7.length-1].price/last7[0].price-1:0;
  const rets=[]; for(let i=1;i<arr.length;i++){ const r=Math.log(arr[i].price/arr[i-1].price); if(isFinite(r)) rets.push(r); }
  const m=rets.reduce((s,x)=>s+x,0)/(rets.length||1);
  const v=rets.reduce((s,x)=>s+(x-m)**2,0)/(rets.length||1);
  const daily=Math.sqrt(v); const ann = daily*Math.sqrt(365);
  return {vol:ann||0.6,r7,r30};
}
function levelsFromSigma(price,side,sigma){
  const band = clamp(sigma*2.2,0.01,0.15);
  const slp = clamp(band*1.0,0.008,0.12);
  const tpp = clamp(band*2.2,0.02,0.3);
  const sl = side==='long'? price*(1-slp): price*(1+slp);
  const tp = side==='long'? price*(1+tpp): price*(1-tpp);
  return {sl,tp};
}
function computeLevels(arr,price,side){
  if(!price || !arr || arr.length<5) return null;
  const rets=[]; for(let i=1;i<arr.length;i++){ const r=Math.log(arr[i].price/arr[i-1].price); if(isFinite(r)) rets.push(r); }
  if(!rets.length) return null;
  const m=rets.reduce((s,x)=>s+x,0)/rets.length;
  const v=rets.reduce((s,x)=>s+(x-m)**2,0)/rets.length;
  const sigma=Math.sqrt(v); return levelsFromSigma(price,side,sigma);
}
function sigmaOf(arr){
  if(!arr||arr.length<5) return null;
  const rets=[]; for(let i=1;i<arr.length;i++){ const r=Math.log(arr[i].price/arr[i-1].price); if(isFinite(r)) rets.push(r); }
  if(!rets.length) return null; const m=rets.reduce((s,x)=>s+x,0)/rets.length;
  const v=rets.reduce((s,x)=>s+(x-m)**2,0)/rets.length; return Math.sqrt(v);
}

// ---------- 自动建议 ----------
function autoSuggest(){
  const sBTC = computeStats(series.BTC||[]);
  const sETH = computeStats(series.ETH||[]);
  const sSUI = computeStats(series.SUI||[]);
  const momMaj = 0.6*((sBTC.r7+sETH.r7)/2) + 0.4*((sBTC.r30+sETH.r30)/2);
  const momAlt = 0.6*sSUI.r7 + 0.4*sSUI.r30;
  const spread = momAlt - momMaj;
  netBias = clamp(0.25*Math.tanh(spread*10), -0.35, 0.35);
  const momentum = Math.min(1, Math.abs(spread)*3);
  const riskVol = Math.max(sBTC.vol,sETH.vol,sSUI.vol);
  const up = 0.8*momentum;
  const down = Math.max(0, (riskVol-0.9)/0.1)*0.15;
  grossLev = clamp(2.0 + up - down, MIN_GROSS, MAX_GROSS);

  // 方向
  const altsLong = spread>0;
  sides = {
    SUI: altsLong?'long':'short',
    WAL: altsLong?'long':'short',
    DEEP: altsLong?'long':'short',
    BTC: altsLong?'short':'long',
    ETH: altsLong?'short':'long',
  };
  // 杠杆（随波动）
  const toLev = v => clamp(1.5/Math.max(0.1,v), MIN_LEV, MAX_LEV);
  lev.BTC = toLev(sBTC.vol); lev.ETH = toLev(sETH.vol); lev.SUI = toLev(sSUI.vol);

  // 权重
  const invB=1/Math.max(0.0001,sBTC.vol), invE=1/Math.max(0.0001,sETH.vol);
  const tot=invB+invE; weightsMaj = {BTC:invB/tot*100, ETH:invE/tot*100};
  const suiShare = clamp(70 + 20*Math.tanh(spread*10), 50, 90);
  const rest = 100 - suiShare; weightsAlt = {SUI:suiShare, WAL:rest*0.6, DEEP:rest*0.4};

  renderAll();
}

// ---------- 渲染 ----------
function norm(weights, keys){ const T=keys.reduce((s,k)=>s+(weights[k]||0),0)||1; const out={}; keys.forEach(k=> out[k]=clamp((weights[k]||0)/T,0,1)); return out; }
function renderBuckets(){
  const nAlt = norm(weightsAlt, ALT.map(a=>a.symbol));
  const nMaj = norm(weightsMaj, MAJ.map(a=>a.symbol));
  const makeCard = (title, sub, arr, n, defSide)=>{
    const blocks = arr.map(a=>{
      const side = defSide;
      const w = (weightsAlt[a.symbol] ?? weightsMaj[a.symbol] ?? 0).toFixed(1);
      const lv = lev[a.symbol]?.toFixed(2) || '—';
      const px = prices[a.symbol]; const priceTxt = isFinite(px)? '$'+fmt(px, px>999?0:6):'—';
      return `<div class="card" style="padding:12px;border-radius:12px;background:#0c121a;border-color:#18202c">
        <div class="row" style="justify-content:space-between;margin-bottom:6px">
          <div class="row"><strong>${a.symbol}</strong>&nbsp;<span class="badge ${defSide==='long'?'b-long':'b-short'}">${defSide==='long'?'做多':'做空'}</span></div>
          <span class="tag">${sub}</span>
        </div>
        <div class="row" style="justify-content:space-between"><span class="muted">权重</span><span>${w}%</span></div>
        <div class="row" style="justify-content:space-between"><span class="muted">杠杆</span><span>${lv}×</span></div>
        <div class="row" style="justify-content:space-between"><span class="muted">现价（USD）</span><span>${priceTxt}</span></div>
      </div>`;
    }).join('');
    return `<div><div class="row" style="justify-content:space-between;margin-bottom:6px"><div class="title">${title}</div><span class="tag">${sub}</span></div>
      <div class="two">${blocks}</div>
      <div class="foot">权重在该篮子内自动归一化，总计 ${(Object.values(n).reduce((s,x)=>s+x,0)*100).toFixed(1)}% → 100%。</div>
    </div>`;
  };
  $('#altCard').innerHTML = makeCard('山寨篮子','SUI / WAL / DEEP', ALT, nAlt, sides.SUI);
  $('#majCard').innerHTML = makeCard('主流篮子','BTC / ETH', MAJ, nMaj, sides.BTC);
}

function renderDialAndKPI(rows){
  const bias = netBias;
  const deg = Math.max(-120, Math.min(120, bias*120));
  $('#needle').style.transform = `translate(-50%,-100%) rotate(${deg}deg)`;
  $('#biasText').textContent = bias>0.06?'偏多':(bias<-0.06?'偏空':'中性');
  $('#netTarget').textContent = Math.round(bias*100)+'%';
  const long = rows.filter(r=>r.side==='long').reduce((s,r)=>s+r.notional,0);
  const short = rows.filter(r=>r.side==='short').reduce((s,r)=>s+r.notional,0);
  $('#kLong').textContent = usd(long);
  $('#kShort').textContent = usd(short);
  $('#grossPill').textContent = '总杠杆：≈ '+fmt((long+short)/Math.max(1,deposit),1)+'×';
}


function renderTable(rows){
  const tb = $('#tbl tbody'); tb.innerHTML='';

  // --- 计算“原始投入”（名义/杠杆），然后按总投入=deposit 归一化并取整 ---
  const raw = rows.map(r=> (isFinite(r.notional)&&isFinite(r.leverage)&&r.leverage>0)? r.notional/r.leverage : 0);
  const sumRaw = raw.reduce((s,x)=>s+x,0);
  const target = Number($('#deposit').value||deposit||0);

  let alloc = rows.map((_,i)=> sumRaw>0? (target * raw[i] / sumRaw) : 0);
  // Hamilton/最大余数法：先取地板，再按小数部分从大到小分配剩余
  const floors = alloc.map(x=> Math.floor(x));
  let rem = Math.max(0, Math.round(target - floors.reduce((s,x)=>s+x,0)));
  const frac = alloc.map((x,i)=> ({i, f: x - floors[i]})).sort((a,b)=> b.f - a.f);
  for(let k=0;k<rem;k++){ floors[frac[k % floors.length].i] += 1; }

  // 渲染
  rows.forEach((r,idx)=>{
    const invested = floors[idx]; // 归一化后的投入USDC（整数）
    const tr = document.createElement('tr');
    tr.innerHTML = `<td style="font-weight:600">${r.symbol}</td>
      <td style="text-align:right"><span class="badge ${r.side==='long'?'b-long':'b-short'}">${r.side}</span></td>
      <td>${usd(r.price)}</td>
      <td>${(r.weight*100).toFixed(1)}%</td>
      <td>${(r.leverage||0).toFixed(1)}×</td>
      <td>${usd(r.notional)}</td>
      <td>${Number(invested).toLocaleString()}</td>
      <td>${isFinite(r.sl)? usd(r.sl):'—'}</td>
      <td>${isFinite(r.tp)? usd(r.tp):'—'}</td>`;
    tb.appendChild(tr);
  });
}

function buildRows(){
  const nAlt = norm(weightsAlt, ALT.map(a=>a.symbol));
  const nMaj = norm(weightsMaj, MAJ.map(a=>a.symbol));

  const longBase = MAJ.reduce((s,a)=> sides[a.symbol]==='long'? s + deposit*nMaj[a.symbol]*(lev[a.symbol]||0) : s,0)
                   + ALT.reduce((s,a)=> sides[a.symbol]==='long'? s + deposit*nAlt[a.symbol]*(lev[a.symbol]||0) : s,0);
  const shortBase= MAJ.reduce((s,a)=> sides[a.symbol]==='short'? s + deposit*nMaj[a.symbol]*(lev[a.symbol]||0) : s,0)
                   + ALT.reduce((s,a)=> sides[a.symbol]==='short'? s + deposit*nAlt[a.symbol]*(lev[a.symbol]||0) : s,0);
  const grossTarget = grossLev*deposit;
  const netTarget = netBias*deposit;
  const longTarget = Math.max(0,(grossTarget+netTarget)/2);
  const shortTarget= Math.max(0,(grossTarget-netTarget)/2);
  const scaleLong = longBase>0? longTarget/longBase:1;
  const scaleShort= shortBase>0? shortTarget/shortBase:1;

  const rows=[...ALT.map(a=>({bucket:'alt',symbol:a.symbol,name:a.name,side:sides[a.symbol],weight:nAlt[a.symbol],leverage:lev[a.symbol]})),
              ...MAJ.map(a=>({bucket:'maj',symbol:a.symbol,name:a.name,side:sides[a.symbol],weight:nMaj[a.symbol],leverage:lev[a.symbol]}))]
              .map(r=>{
                const base = deposit*r.weight*(r.leverage||0);
                const notional = r.side==='long'? base*scaleLong: base*scaleShort;
                const price = prices[r.symbol]||0;
                const qty = price>0? notional/price:0;
                let lv = computeLevels(series[r.symbol]||[], price, r.side);
                if(!lv){
                  const self = sigmaOf(series[r.symbol]||[]);
                  const proxy = sigmaOf(series.SUI||[]);
                  const sigma = (self ?? proxy ?? 0.02);
                  lv = levelsFromSigma(price, r.side, sigma);
                }
                return {...r,price,notional,qty,sl:lv.sl,tp:lv.tp};
              });
  return rows;
}

function renderAll(){
  renderBuckets();
  const rows = buildRows();
  renderDialAndKPI(rows);
  renderTable(rows);
}

// ---------- 操作 ----------
async function refreshAll(){
  $('#err').textContent=''; $('#refresh').disabled=true;
  try{
    await fetchGecko();
    await fetchBinanceWAL();
    await fetchGeckoHistorySafe(120);
    $('#updated').textContent='刚刚刷新：'+ new Date().toLocaleTimeString();
    autoSuggest();
    await runBacktest(7);
  }catch(e){
    $('#err').textContent = '行情拉取失败：' + (e?.message||e);
  }finally{
    $('#refresh').disabled=false;
  }
}
function setDeposit(v){ deposit=v; $('#deposit').value=v; renderAll(); }
$('#deposit').addEventListener('input', e=>{ deposit = Math.max(0, Number(e.target.value||0)); renderAll(); });

function exportPlan(){
  const rows = buildRows();
  const totals = {
    longNotional: rows.filter(r=>r.side==='long').reduce((s,r)=>s+r.notional,0),
    shortNotional: rows.filter(r=>r.side==='short').reduce((s,r)=>s+r.notional,0),
  };
  const plan = {
    timestamp:new Date().toISOString(),
    deposit, netBias, targetGrossLev:grossLev,
    weights:{alts:norm(weightsAlt, ALT.map(a=>a.symbol)), majors:norm(weightsMaj, MAJ.map(a=>a.symbol))},
    leverage:lev, prices,
    positions: rows.map(({symbol,side,qty,notional,price,leverage,weight,sl,tp})=>({symbol,side,qty,notional,price,leverage,weight,sl,tp})),
    totals,
  };
  const blob = new Blob([JSON.stringify(plan,null,2)],{type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = `pebble-plan-${Date.now()}.json`; a.click(); URL.revokeObjectURL(url);
}

// 初始拉取与渲染
(async function init(){
  await refreshAll();
})();
</script>

  <div class="card" style="margin-top:16px">
    <div class="title">历史回测：组合 vs BTC</div>
    <div class="muted">自动展示最近 7 天的累计收益：按策略组合 vs 持有 BTC（1×）。若数据源短时不可用，将显示提示。</div>
    <div style="overflow:auto;margin-top:8px">
      <table id="btbl">
        <thead>
          <tr>
            <th>日期</th>
            <th>组合累计收益</th>
            <th>BTC累计收益</th>
            <th>差值（组合-BTC）</th>
          </tr>
        </thead>
        <tbody></tbody>
      </table>
    </div>
  </div>

<script>
// ---------- 工具 ----------
function fmtPct(x){ return (isFinite(x)? (x*100).toFixed(2)+'%' : '—'); }
function ymdUTC(ts){ const d=new Date(ts); return `${d.getUTCFullYear()}-${String(d.getUTCMonth()+1).padStart(2,'0')}-${String(d.getUTCDate()).padStart(2,'0')}`; }
function resampleDailyLast(arr){
  const m = new Map();
  for(const p of arr||[]){
    const d = new Date(p.ts); const key = Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate());
    m.set(key, p.price);
  }
  return Array.from(m.entries()).sort((a,b)=>a[0]-b[0]).map(([ts,price])=>({ts,price}));
}
function pctOver(arr, i, win){
  if(i-win<0) return 0;
  const v = arr[i].price/arr[i-win].price - 1;
  return isFinite(v)? v: 0;
}
function logRet(arr, i){
  if(i<=0 || i>=arr.length) return 0;
  const r = Math.log(arr[i].price/arr[i-1].price);
  return isFinite(r)? r: 0;
}
function annSigma(arr, i, win){
  const rs=[];
  for(let k=Math.max(1,i-win+1); k<=i; k++){ const r=logRet(arr,k); if(isFinite(r)) rs.push(r); }
  if(!rs.length) return 0.9; // 默认
  const m = rs.reduce((s,x)=>s+x,0)/rs.length;
  const v = rs.reduce((s,x)=>s+(x-m)*(x-m),0)/rs.length;
  return Math.sqrt(v)*Math.sqrt(365);
}

// ---------- 历史行情（独立，不改动原有函数） ----------
async function fetchGeckoHistorySafe(days=120){
  if(typeof series!=='object') window.series = {};
  const meta = [...ALT, ...MAJ].filter(x=>x.id).map(x=>({id:x.id, sym:x.symbol}));
  for(const {id,sym} of meta){
    try{
      const url = `https://api.coingecko.com/api/v3/coins/${id}/market_chart?vs_currency=usd&days=${days}&interval=daily`;
      const j = await fetch(url, {cache:'no-store'}).then(r=>r.json());
      const arr = (j.prices||[]).map(([ts,price])=>({ts,price})).filter(p=>isFinite(p.price));
      if(arr.length) series[sym] = arr;
    }catch(e){ /* 忽略失败，保持已有 */ }
  }
}

// ---------- 回测（最近 N 天） ----------

async function runBacktest(lastDays=7){
  try{
    const tb = document.querySelector('#btbl tbody'); tb.innerHTML='';
    // 1) 准备日线历史（BTC/ETH 必需；山寨用 SUI/WAL/DEEP 中任意可用的集合）
    const daily = {}; const names = ['BTC','ETH','SUI','WAL','DEEP'];
    for(const s of names){ daily[s] = resampleDailyLast((series && series[s])? series[s] : []); }

    const haveMaj = daily.BTC.length>10 && daily.ETH.length>10;
    const altList = names.slice(2).filter(s=>daily[s].length>10);
    if(!haveMaj || altList.length===0){
      const tr = document.createElement('tr');
      tr.innerHTML = '<td colspan="4" class="muted">暂无数据：缺少主流或山寨的日线历史，无法回测（可稍后刷新再试）。</td>';
      tb.appendChild(tr); return;
    }

    // 2) 以日期字符串对齐：取 BTC/ETH 与 至少一个山寨 的交集
    const setDates = (arr)=> new Set(arr.map(p=>ymdUTC(p.ts)));
    let dates = [...setDates(daily.BTC)].filter(d=> setDates(daily.ETH).has(d));
    // 至少一个山寨在这一天有数据即可
    const altHas = (d)=> altList.some(s=> setDates(daily[s]).has(d));
    dates = dates.filter(d=> altHas(d));
    dates.sort();

    // 3) 构建 index map 方便索引
    const idx = {};
    for(const s of names){ const m=new Map(); daily[s].forEach((p,i)=>m.set(ymdUTC(p.ts), i)); idx[s]=m; }

    // 4) 遍历最近 N 天：信号用 t-1 的数据，收益用 t 的一天涨跌
    const rows = [];
    const N = Math.min(lastDays, Math.max(0, dates.length-1));
    for(let k=dates.length-N; k<dates.length; k++){
      const d = dates[k];
      const kBTC = idx.BTC.get(d), kETH = idx.ETH.get(d);
      // 需要上一日
      const prev = dates[k-1];
      if(prev==null){ continue; }
      const jBTC = idx.BTC.get(prev), jETH = idx.ETH.get(prev);
      if(jBTC==null || jETH==null){ continue; }

      // —— 计算 t-1 的动量（7/30），对没有30D历史的降级为“只用可用窗口”，并重标权重
      function momPair(arr, i){
        const r7 = (i>=7)? (arr[i].price/arr[i-7].price - 1) : null;
        const r30= (i>=30)? (arr[i].price/arr[i-30].price - 1) : null;
        let w7=0, w30=0;
        if(r7!=null) w7 += 0.6;
        if(r30!=null) w30+= 0.4;
        const norm = (w7+w30)||1;
        return ((r7||0)*w7 + (r30||0)*w30)/norm;
      }
      const momMaj = (momPair(daily.BTC, jBTC)+momPair(daily.ETH, jETH))/2;
      // 山寨动量取“可用山寨的平均”，优先 SUI；没有30D时也降级
      let momAlt = 0, cntAlt=0;
      for(const s of altList){
        const j = idx[s].get(prev);
        if(j!=null){ momAlt += momPair(daily[s], j); cntAlt++; }
      }
      if(cntAlt>0) momAlt/=cntAlt;

      const spread = momAlt - momMaj;

      // —— 风险/杠杆：波动率用最近 30 天（不足则用可用天数），默认年化 0.9
      function annSigmaAt(arr, i, win=30){
        const start = Math.max(1, i-Math.min(win,i));
        const rs=[];
        for(let t=start; t<=i; t++){ const r = Math.log(arr[t].price/arr[t-1].price); if(isFinite(r)) rs.push(r); }
        if(!rs.length) return 0.9;
        const m = rs.reduce((s,x)=>s+x,0)/rs.length;
        const v = rs.reduce((s,x)=>s+(x-m)*(x-m),0)/rs.length;
        return Math.sqrt(v)*Math.sqrt(365);
      }
      const riskVol = Math.max(annSigmaAt(daily.BTC, jBTC), annSigmaAt(daily.ETH, jETH), ...altList.map(s=> annSigmaAt(daily[s], idx[s].get(prev)||0)));
      const momentum = Math.min(1, Math.abs(spread)*3);
      const netBias = Math.max(-0.35, Math.min(0.35, 0.25*Math.tanh(spread*10)));
      const up = 0.8*momentum;
      const down = Math.max(0, (riskVol-0.9)/0.1)*0.15;
      const MIN_GROSS=2.2, MAX_GROSS=3.2;
      const grossLev = Math.max(MIN_GROSS, Math.min(MAX_GROSS, 2.0 + up - down));

      // —— 方向（基于 spread 的符号，t-1 的信号）
      const altsLong = spread>0;
      const sides = {BTC:'long', ETH:'long', SUI: altsLong?'long':'short', WAL: altsLong?'long':'short', DEEP: altsLong?'long':'short'};

      // —— 当日 r(t)（从 t-1 到 t 的一天收益）
      function dayR(arr, i){ if(i<=0) return 0; const r=Math.log(arr[i].price/arr[i-1].price); return isFinite(r)? r:0; }
      const rDay = {
        BTC: dayR(daily.BTC, kBTC),
        ETH: dayR(daily.ETH, kETH),
      };
      for(const s of altList){
        const kAlt = idx[s].get(d), jAlt = idx[s].get(prev);
        rDay[s] = (kAlt!=null && jAlt!=null)? dayR(daily[s], kAlt): 0;
      }

      // —— 权重与名义缩放（仅对“当天有数据”的币计入）
      const dep = deposit||10000;
      const wAltRaw = {SUI:(weightsAlt?.SUI||0), WAL:(weightsAlt?.WAL||0), DEEP:(weightsAlt?.DEEP||0)};
      const wMajRaw = {BTC:(weightsMaj?.BTC||0), ETH:(weightsMaj?.ETH||0)};
      const sAlt = (wAltRaw.SUI+wAltRaw.WAL+wAltRaw.DEEP)||1;
      const sMaj = (wMajRaw.BTC+wMajRaw.ETH)||1;
      const nAlt = {SUI:wAltRaw.SUI/sAlt, WAL:wAltRaw.WAL/sAlt, DEEP:wAltRaw.DEEP/sAlt};
      const nMaj = {BTC:wMajRaw.BTC/sMaj, ETH:wMajRaw.ETH/sMaj};
      const L = (sym)=> (lev?.[sym]||0);
      const hasData = (sym)=> (sym==='BTC')? true : (sym==='ETH'? true : altList.includes(sym));

      const longBase = ['BTC','ETH','SUI','WAL','DEEP'].filter(s=>sides[s]==='long' && hasData(s)).reduce((s,sym)=> s + dep*((nAlt[sym]||nMaj[sym]||0))*L(sym), 0);
      const shortBase= ['BTC','ETH','SUI','WAL','DEEP'].filter(s=>sides[s]==='short'&& hasData(s)).reduce((s,sym)=> s + dep*((nAlt[sym]||nMaj[sym]||0))*L(sym), 0);
      const longTarget = Math.max(0,(grossLev*dep + netBias*dep)/2);
      const shortTarget= Math.max(0,(grossLev*dep - netBias*dep)/2);
      const scaleLong = longBase>0? longTarget/longBase: 1;
      const scaleShort= shortBase>0? shortTarget/shortBase: 1;

      let pnl=0;
      for(const sym of ['BTC','ETH', ...altList]){
        const w = (nAlt[sym]||nMaj[sym]||0);
        if(!w) continue;
        const base = dep*w*L(sym);
        const notional = (sides[sym]==='long'? base*scaleLong : base*scaleShort);
        pnl += notional * (sides[sym]==='long'? rDay[sym] : -rDay[sym]);
      }
      const strat1d = pnl/dep;
      const btc1d = rDay.BTC;
      rows.push({date:d, strat1d, btc1d, diff: strat1d - btc1d});
    }

    // 5) 渲染最近 N 天（按天收益，不累计）
    if(!rows.length){
      const tr = document.createElement('tr');
      tr.innerHTML = '<td colspan="4" class="muted">暂无数据：窗口内没有可对齐的日期。</td>';
      tb.appendChild(tr); return;
    }
    tb.innerHTML='';
    for(const r of rows){
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${r.date}</td><td>${fmtPct(Math.expm1(r.strat1d))}</td><td>${fmtPct(Math.expm1(r.btc1d))}</td><td>${fmtPct(Math.expm1(r.diff))}</td>`;
      tb.appendChild(tr);
    }
  }catch(e){
    const tb = document.querySelector('#btbl tbody'); tb.innerHTML='';
    const tr = document.createElement('tr');
    tr.innerHTML = '<td colspan="4" class="muted">回测出错：'+ (e?.message||e) +'</td>';
    tb.appendChild(tr);
  }
}
</script>

<script>window.addEventListener('load', ()=>{ try{ refreshAll(); }catch(e){} });</script>
</body>
</html>
